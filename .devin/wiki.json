{
  "repo_notes": [
    {
      "content": ""
    }
  ],
  "pages": [
    {
      "title": "Overview",
      "purpose": "Introduce SCUFFLE (Soul Calibur Live Frame Data Reader), explaining what it is, its purpose as a training tool for Soul Calibur 6, and high-level architecture",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Features and Limitations",
      "purpose": "Detail what SCUFFLE can and cannot do, including known limitations like stance transitions and the requirement for windowed mode",
      "parent": "Overview",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "System Requirements",
      "purpose": "Specify Python version requirements, operating system (Windows), and Soul Calibur 6 compatibility",
      "parent": "Overview",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Getting Started",
      "purpose": "Guide users through initial setup, launching SCUFFLE, and basic configuration to get the overlay working",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Installation",
      "purpose": "Walk through setting up Python environment, installing dependencies, and preparing the application",
      "parent": "Getting Started",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Launching and Basic Usage",
      "purpose": "Explain how to launch SCUFFLE alongside Soul Calibur 6, configure windowed mode, and verify the overlay is working",
      "parent": "Getting Started",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Core Architecture",
      "purpose": "Provide comprehensive overview of SCUFFLE's internal systems and how they interact with each other",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Memory Reading System",
      "purpose": "Explain how SCUFFLE reads game memory, including Windows API usage and address resolution",
      "parent": "Core Architecture",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "ByteTools: Windows API Interface",
      "purpose": "Detail the ByteTools module, explaining OpenProcess, ReadProcessMemory, WriteProcessMemory, and data type handling",
      "parent": "Core Architecture",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "AddressMap: Memory Address Management",
      "purpose": "Explain how AddressMap defines and manages game memory addresses for players, moves, and game state",
      "parent": "Core Architecture",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Configuration System",
      "purpose": "Describe the configuration architecture and how ConfigReader parses and manages INI files",
      "parent": "Core Architecture",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "ConfigReader Implementation",
      "purpose": "Deep dive into ConfigReader class methods, default value handling, and INI file persistence",
      "parent": "Core Architecture",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Frame Data Overlay System",
      "purpose": "Explain how the overlay renders on top of Soul Calibur 6, what data it displays, and how it's calculated",
      "parent": "Core Architecture",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Script Definition System",
      "purpose": "Overview of how script JSON files define game commands, states, and conditions that SCUFFLE interprets",
      "parent": "Core Architecture",
      "page_notes": [
        {
          "content": "Overview of how script JSON files define game commands, states, and conditions that SCUFFLE interprets. All commands use either three or one byte sets to distinguish how the data should be handled. In three byte sets, the first byte is used to determine how the value should be handled, with the other two being read as a 16-bit(short) int. 89 is used for constants, 8a for referencing a variable and 8b for an encoded/shortcut value. Each command ends with the type (A5, 25), subtype (01, 0d, 14, 19, 25, 26) and the arguments +1 for the state id (Ex: 8b 30 20 8b 00 c8 89 00 05 89 00 0a 25 0d 04).One byte math/compare operations: 8c - ADD, 8d - SUB, 8e - MULT, 8f - DIV, 90 - MOD, 91 - Flip Sign, 94 - bitwise AND, 95 - bitwise OR, 96 - NOT (Only returns 0 or 1), 98 - bit shift right >>, 9f - =, a0 - !=, a1 - <, a2 - <=, a3 - >, a4 - >=. Layout for math operations: [constant or variable][constant or variable][math operator byte]. math/compare operations don't have type bytes and are like 19 xx xx, which is used for assigning a variable (89 00 01 19 01 00). An example math/compare operation: 8a 01 00 89 00 02 8e 19 01 00. variables are grouped for different purposes: 19/8a 00 xx -> universal vars, 19/8a 01 xx -> seemingly local vars, 19/8a 00 f0-ff? -> input param to move script (f0 is input arg 1, f1 is for 2 etc..)."
        }
      ]
    },
    {
      "title": "Configuration Reference",
      "purpose": "Comprehensive reference for all configuration files and their settings",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Address Map Configuration",
      "purpose": "Detail every address in address_map.ini, what data it points to, and how to update addresses after patches",
      "parent": "Configuration Reference",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Global Addresses",
      "purpose": "Document global timer and shared game state addresses",
      "parent": "Configuration Reference",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Player Data Addresses",
      "purpose": "Document all player-specific addresses including input buffers, movelists, move IDs, guard damage, and hitboxes",
      "parent": "Configuration Reference",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Visual Customization",
      "purpose": "Guide to customizing SCUFFLE's appearance through color schemes and fonts",
      "parent": "Configuration Reference",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Color Schemes",
      "purpose": "Document all available color themes and how to create custom themes",
      "parent": "Configuration Reference",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Font Configuration",
      "purpose": "Explain font settings for different UI components and how to modify them",
      "parent": "Configuration Reference",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Overlay Display Settings",
      "purpose": "Configure overlay behavior including draggability, transparency, focus detection, and data column visibility",
      "parent": "Configuration Reference",
      "page_notes": [
        {
          "content": ""
        }
      ]
    },
    {
      "title": "Script System Reference",
      "purpose": "Complete reference for understanding and working with SCUFFLE's script definition system",
      "page_notes": [
        {
          "content": "When a move is loaded in the Move Editor (Ex: 264 for standing A), the bytes in the 'Scripting' tab are processed using the JSON Schema to give known commands appropriate labels. If Type 03 commands are unknown they're labeled as 'SYSTEM SCRIPT: [id:state_id]. If Type 25/0d commands are unknown they're labeled as 'MOVE SCRIPT: [id:state_id]. If Type 25/14 commands are unknown they're labeled as 'SET STATE: [id:state_id][value:value]. The 'get_gui_guide()' function in the 'Cancel' class located in MovelistParser.py specifies command labeling for commands/types that don't use a common layout, so refer to the code there for types like A5/25 --> FRAME CHECK, Type 25/26 --> SET ACTIVE HITBOX, Type 19/xxxx for SET VARAIBLE, etc.."
        }
      ]
    },
    {
      "title": "Script JSON Structure",
      "purpose": "Explain the JSON schema for script definitions including state, script_type, name, and args structure",
      "parent": "Script System Reference",
      "page_notes": [
        {
          "content": "Explain the JSON schema for script definitions including state, script_type, name, and args structure. also add documentation of the format_value() function located in MovelistParser.py"
        }
      ]
    },
    {
      "title": "Script Types Overview",
      "purpose": "Overview of different script_type categories and their purposes",
      "parent": "Script System Reference",
      "page_notes": [
        {
          "content": "Overview of different script_type categories and their purposes. Add a section for character id directories ('Scripts/[character_id]/') and the 'Scripts/Custom' directory that is created when opening the Move Editor if it doesn't exist. 'Scripts/[character_id]/' and 'Scripts/Custom' directories mirror the 'Scripts/Common' directory's structure, allowing the end user to add script entries for a particualar character to 'Scripts/[character_id]/' or just add entries that won't be lost due to an offical update to the JSON in the Common directory. Directory priortity order is Character -> Custom -> Common"
        }
      ]
    },
    {
      "title": "General System Commands (Type 03)",
      "purpose": "Document script_type 03 commands for animations, movement, combat mechanics, visual/audio effects, and camera control.",
      "parent": "Script System Reference",
      "page_notes": [
        {
          "content": "Type 25/03 commands are system-level commands, calling internal game functions to change game behavior. These commands can be set to execute exclusively on a specifed frame by prefixing a frame number before the state id and calling them with type 19 instead of 03. Ex: [state_id][args...][25][03][arg_count] --> [frame][state_id][args...][25][19][arg_count+1]"
        }
      ]
    },
    {
      "title": "State Commands (Type 25/0d)",
      "purpose": "Document script_type 0d commands for special states, Soul Charge mechanics, meter management, and attack properties",
      "parent": "Script System Reference",
      "page_notes": [
        {
          "content": "For Type 25/0d commands the state id refers to a move id in the movelist, allowing editing of that command's script logic unlike Type 03 where the logic is controlled in a internal game function."
        }
      ]
    },
    {
      "title": "Condition Checks (Type A5/01 and Type A5/0d)",
      "purpose": "Document condition check scripts for button inputs, character states, opponent properties, and game state queries",
      "parent": "Script System Reference",
      "page_notes": [
        {
          "content": "Type A5/01 is used for either system-level checks or fetching particular values such as current frame and active start/end frame from the hitbox data. Type A5/0d is like Type 25/0d but is a 'CUSTOM CHECK' that returns a value specified in that move script (refer to Type 25/0d)"
        }
      ]
    },
    {
      "title": "State Manipulation (Type 25/14)",
      "purpose": "Document script_type 14 commands for stun mechanics, persona changes, and time manipulation",
      "parent": "Script System Reference",
      "page_notes": [
        {
          "content": "Type 25/14 commands set specified character states to provided values."
        }
      ]
    },
    {
      "title": "Data Types Reference",
      "purpose": "Complete reference for all value_type enumerations used in script arguments",
      "parent": "Script System Reference",
      "page_notes": [
        {
          "content": ""
        }
      ]
    }
  ]
}
